#! /usr/bin/env python3

import sys
import random
import itertools
import collections
from typing import Dict, Tuple, Sequence, Any

Histogram = Dict[bytes, float]

ASCII_RANGE = range(0, 128)


def sliding_window(items: Sequence, size: int) -> Sequence:
    return [items[start:end] for start, end
            in zip(range(0, len(items) - size), range(size, len(items)))]


def analyze(filename: str, max_ngram_size: int) -> Sequence[Histogram]:
    def count_ngrams(ngrams: Sequence[bytes], keys: Sequence[bytes]) -> Histogram:
        raw_histogram = collections.Counter(ngrams)
        # Additive smoothing for vertical asymptotes at zeros for chi function
        histogram = {key: raw_histogram[key] + 1 for key in keys}
        histogram_size = sum(histogram.values())
        return {key: val / histogram_size for key, val in histogram.items()}

    def ngram_range(ngram_size: int) -> Sequence[bytes]:
        return [bytes(ngram) for ngram
                in itertools.product(*itertools.repeat(ASCII_RANGE, ngram_size))]

    contents = open(filename, 'rb').read()
    return [count_ngrams(sliding_window(contents, ngram_size), ngram_range(ngram_size))
            for ngram_size in range(1, max_ngram_size + 1)]


def dump_analysis(analysis: Histogram) -> None:
    def get_value(item: Tuple[Any, Any]) -> Any:
        key, val = item
        return val

    for key, val in sorted(analysis.items(), key=get_value, reverse=True):
        print(f"{repr(key.decode('ascii')):>16s}: {val:.6f}")
    print()


def chi_score(plaintext: bytes, base_histogram: Histogram, group_size: int) -> float:
    def expected_freq(val: bytes) -> float:
        BAD_NGRAM_FREQ = 1e-6
        return base_histogram.get(val, BAD_NGRAM_FREQ)

    histogram = collections.Counter(sliding_window(plaintext, group_size))
    num_chars = len(plaintext) - group_size + 1
    return sum((count / num_chars - expected_freq(val))**2 / expected_freq(val)
               for val, count in histogram.items())


def score_solution(plaintext: bytes, analysis: Sequence[Histogram]) -> float:
    return sum(chi_score(plaintext, histogram, index + 1)
               for index, histogram in enumerate(analysis))


def decrypt(ciphertext: bytes, password: bytes) -> bytes:
    return bytes(cipher_item - pw_item for cipher_item, pw_item
                 in zip(ciphertext, itertools.cycle(password)))


def format_string(string: bytes) -> str:
    def format_byte(val: int):
        return chr(val) if 32 <= val < 128 else 'â€¢'
    return ''.join(format_byte(val) for val in string)


def find_password(ciphertext: bytes, analysis: Sequence[Histogram],
                  password_size: int, max_moves: int = 8192) -> Tuple[bytes, float]:

    def try_move(index: int, val: int) -> Tuple[float, bytes]:
        new_password = password[:index] + bytes([val]) + password[index + 1:]
        score = score_solution(decrypt(ciphertext, new_password), analysis)
        return score, new_password

    def find_best_move() -> Tuple[float, bytes]:
        return min(try_move(index, val) for index in range(password_size)
                   for val in ASCII_RANGE)

    random.seed(0)
    password = bytes(random.choice(ASCII_RANGE)
                     for index in range(password_size))
    score = score_solution(decrypt(ciphertext, password), analysis)
    for move_count in range(max_moves):
        new_score, new_password = find_best_move()
        if password == new_password:
            break
        else:
            score, password = new_score, new_password
    return password, score


def crack(ciphertext: bytes, analysis: Sequence[Histogram],
          max_password_size: int) -> None:
    for password_size in range(1, max_password_size + 1):
        password, score = find_password(ciphertext, analysis, password_size)
        print(f"{format_string(password)}: {score:.3f} -> "
              f"{format_string(decrypt(ciphertext, password))}")


program, crib_mine_file, max_ngram_size_str, max_password_size_str = sys.argv
max_ngram_size = int(max_ngram_size_str)
max_password_size = int(max_password_size_str)

analysis = analyze(crib_mine_file, max_ngram_size)
ciphertext = sys.stdin.buffer.read()
crack(ciphertext, analysis, max_password_size)
