#! /usr/bin/env python3

import sys
import math
import random
import itertools
import collections
from dataclasses import dataclass
from typing import Dict, Tuple, Sequence, Any

Histogram = Dict[bytes, float]

ASCII_RANGE = range(0, 128)


@dataclass
class Histogram:
    """ngram frequency analysis for a plaintext document."""
    ngram_size: int
    counts: Dict[bytes, int] # Counts for each ngram
    total_count: int # Total number of ngrams


def sliding_window(items: Sequence, size: int) -> Sequence:
    return [items[start:end] for start, end
            in zip(range(0, len(items) - size), range(size, len(items)))]


def analyze(filename: str, max_ngram_size: int) -> Sequence[Histogram]:
    def analyze_ngrams(ngrams: Sequence[bytes], size: int) -> Histogram:
        raw_counts = collections.Counter(ngrams)
        # Additive smoothing for vertical asymptotes at zeros for chi function
        # Read: count is 1 for any missing ngram in ASCII_RANGE**size
        counts = collections.defaultdict(lambda: 1,
                     {key: val + 1 for key, val in raw_counts.items()})
        total_count = sum(raw_counts.values()) + len(ASCII_RANGE) ** size
        return Histogram(ngram_size=size, counts=counts,
                         total_count=total_count)

    contents = open(filename, 'rb').read().lower()
    return [analyze_ngrams(sliding_window(contents, ngram_size), ngram_size)
            for ngram_size in range(1, max_ngram_size + 1)]


def dump_analysis(analysis: Histogram) -> None:
    def get_value(item: Tuple[Any, Any]) -> Any:
        key, val = item
        return val

    for key, val in sorted(analysis.items(), key=get_value, reverse=True):
        print(f"{repr(key.decode('ascii')):>16s}: {val:.6f}")
    print()


def chi_score(plaintext: bytes, histogram: Histogram) -> float:
    def chi_term(val: bytes, count: int):
        """Compute offset to replace term for zero count with nonzero count."""
        expected_count = histogram.counts[val] \
                       / histogram.total_count * num_ngrams
        remove_term = expected_count
        add_term = (count - expected_count)**2 / expected_count
        return -remove_term + add_term

    ngrams = sliding_window(plaintext, histogram.ngram_size)
    counts = collections.Counter(ngrams)
    num_ngrams = len(plaintext) - histogram.ngram_size + 1
    chi2 = num_ngrams + sum(chi_term(val, count)
                            for val, count in counts.items())
    return math.sqrt(chi2)


def score_solution(plaintext: bytes, analysis: Sequence[Histogram],
                   weights=None) -> float:
    term_weights = weights or itertools.repeat(1, len(analysis))
    return sum(weight * chi_score(plaintext, histogram)
               for weight, histogram in zip(term_weights, analysis))


def decrypt(ciphertext: bytes, password: bytes) -> bytes:
    return bytes(cipher_item - pw_item for cipher_item, pw_item
                 in zip(ciphertext, itertools.cycle(password)))


def format_string(string: bytes) -> str:
    def format_byte(val: int):
        char = chr(val)
        return char if char.isprintable() else 'â€¢'

    return ''.join(format_byte(val) for val in string)


def columnize(string: bytes, size: int) -> str:
    return '\n'.join(format_string(string[index : index + size])
                     for index in range(0, len(string), size))


def find_password(ciphertext: bytes, analysis: Sequence[Histogram],
                  password_size: int, num_steps: int = 20000) \
                  -> Tuple[bytes, float]:
    """Search the password space for the value with the lowest (best) chi score.
    Use a simulated annealing algorithm:
    https://mathworld.wolfram.com/SimulatedAnnealing.html
    """
    def try_move(index: int, val: int) -> Tuple[float, bytes]:
        new_password = password[:index] + bytes([val]) + password[index + 1:]
        score = score_solution(decrypt(ciphertext, new_password).lower(), analysis, score_weights)
        return score, new_password

    def try_random_move() -> Tuple[float, bytes]:
        return try_move(random.choice(range(password_size)),
                        random.choice(ASCII_RANGE))

    random.seed(0)
    password = bytes(random.choice(ASCII_RANGE)
                     for index in range(password_size))
    junk = decrypt(ciphertext, password).lower()
    score_weights = [1 / chi_score(junk, histogram) for histogram in analysis]
    score = len(analysis)
    temperature = 1
    for step in range(num_steps, 1, -1):
        temperature *= 0.999
        new_score, new_password = try_random_move()
        if new_score < score or \
                math.exp(-(new_score - score) / temperature) > random.random():
            score, password = new_score, new_password
            if step % 100 == 0:
                print(f'{format_string(password)}: {score:.3f}')
    return password, score


def crack(ciphertext: bytes, analysis: Sequence[Histogram],
          max_password_size: int) -> None:
    for password_size in range(max_password_size, max_password_size + 1):
        password, score = find_password(ciphertext, analysis, password_size)
        print(f'{format_string(password)}: {score:.3f} ->')
        print(f'{columnize(decrypt(ciphertext, password), password_size)}')


program, crib_mine_file, max_ngram_size_str, max_password_size_str = sys.argv
max_ngram_size = int(max_ngram_size_str)
max_password_size = int(max_password_size_str)

analysis = analyze(crib_mine_file, max_ngram_size)
ciphertext = sys.stdin.buffer.read()
crack(ciphertext, analysis, max_password_size)
