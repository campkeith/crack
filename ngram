#! /usr/bin/env python3

import sys
import math
import random
import itertools
import collections
from typing import Dict, Tuple, Sequence, Any

Histogram = Dict[bytes, float]

ASCII_RANGE = range(0, 128)


def sliding_window(items: Sequence, size: int) -> Sequence:
    return [items[start:end] for start, end
            in zip(range(0, len(items) - size), range(size, len(items)))]


def analyze(filename: str, max_ngram_size: int) -> Sequence[Histogram]:
    def count_ngrams(ngrams: Sequence[bytes], keys: Sequence[bytes]) -> Histogram:
        raw_histogram = collections.Counter(ngrams)
        # Additive smoothing for vertical asymptotes at zeros for chi function
        histogram = {key: raw_histogram[key] + 1 for key in keys}
        histogram_size = sum(histogram.values())
        return {key: val / histogram_size for key, val in histogram.items()}

    def ngram_range(ngram_size: int) -> Sequence[bytes]:
        return [bytes(ngram) for ngram
                in itertools.product(*itertools.repeat(ASCII_RANGE, ngram_size))]

    contents = open(filename, 'rb').read()
    return [count_ngrams(sliding_window(contents, ngram_size), ngram_range(ngram_size))
            for ngram_size in range(1, max_ngram_size + 1)]


def dump_analysis(analysis: Histogram) -> None:
    def get_value(item: Tuple[Any, Any]) -> Any:
        key, val = item
        return val

    for key, val in sorted(analysis.items(), key=get_value, reverse=True):
        print(f"{repr(key.decode('ascii')):>16s}: {val:.6f}")
    print()


def chi_score(plaintext: bytes, base_histogram: Histogram, group_size: int) -> float:
    def expected_freq(val: bytes) -> float:
        BAD_NGRAM_FREQ = 1e-6
        return base_histogram.get(val, BAD_NGRAM_FREQ)

    histogram = collections.Counter(sliding_window(plaintext, group_size))
    num_chars = len(plaintext) - group_size + 1
    return sum((count / num_chars - expected_freq(val))**2 / expected_freq(val)
               for val, count in histogram.items())


def score_solution(plaintext: bytes, analysis: Sequence[Histogram]) -> float:
    return sum(chi_score(plaintext, histogram, index + 1)
               for index, histogram in enumerate(analysis))


def decrypt(ciphertext: bytes, password: bytes) -> bytes:
    return bytes(cipher_item - pw_item for cipher_item, pw_item
                 in zip(ciphertext, itertools.cycle(password)))


def format_string(string: bytes) -> str:
    def format_byte(val: int):
        char = chr(val)
        return char if char.isprintable() else 'â€¢'

    return ''.join(format_byte(val) for val in string)


def columnize(string: bytes, size: int) -> str:
    return '\n'.join(format_string(string[index : index + size])
                     for index in range(0, len(string), size))


def find_password(ciphertext: bytes, analysis: Sequence[Histogram],
                  password_size: int, num_steps: int = 500000) \
                  -> Tuple[bytes, float]:
    """Search the password space for the value with the lowest (best) chi score.
    Use a simulated annealing algorithm:
    https://mathworld.wolfram.com/SimulatedAnnealing.html
    """
    def try_move(index: int, val: int) -> Tuple[float, bytes]:
        new_password = password[:index] + bytes([val]) + password[index + 1:]
        score = score_solution(decrypt(ciphertext, new_password).lower(), analysis)
        return score, new_password

    def try_random_move() -> Tuple[float, bytes]:
        return try_move(random.choice(range(password_size)),
                        random.choice(ASCII_RANGE))

    random.seed(99)
    password = bytes(random.choice(ASCII_RANGE)
                     for index in range(password_size))
    score = score_solution(decrypt(ciphertext, password).lower(), analysis)
    temperature = score
    for step in range(num_steps, 1, -1):
        temperature *= 0.99995
        new_score, new_password = try_random_move()
        if new_score < score or \
                math.exp(-(new_score - score) / temperature) > random.random():
            score, password = new_score, new_password
            if step % 100 == 0:
                print(f'{format_string(password)}: {score:.3f}')
    return password, score


def crack(ciphertext: bytes, analysis: Sequence[Histogram],
          max_password_size: int) -> None:
    for password_size in range(max_password_size, max_password_size + 1):
        password, score = find_password(ciphertext, analysis, password_size)
        print(f'{format_string(password)}: {score:.3f} ->')
        print(f'{columnize(decrypt(ciphertext, password), password_size)}')


program, crib_mine_file, max_ngram_size_str, max_password_size_str = sys.argv
max_ngram_size = int(max_ngram_size_str)
max_password_size = int(max_password_size_str)

analysis = analyze(crib_mine_file, max_ngram_size)
ciphertext = sys.stdin.buffer.read()
crack(ciphertext, analysis, max_password_size)
